diff --git a/Dockerfile b/Dockerfile
index 558aac6..84fe051 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -62,7 +62,7 @@ RUN sed -i 's|master|main|g' /opt/exploit-database/searchsploit
 ENV PATH="/usr/local/bin:$PATH"
 
 # Update SearchSploit
-RUN searchsploit -u || echo "Update process completed with errors"
+RUN timeout 60 searchsploit -u || echo "Update process completed with errors"
 
 # Installing net-tools
 RUN apt-get install -y net-tools
diff --git a/check_encoding.py b/check_encoding.py
index 6dfc6ce..db2b9d9 100644
--- a/check_encoding.py
+++ b/check_encoding.py
@@ -2,13 +2,10 @@
 This script checks the encoding of a file.
 """
 import os
-import logging
 import argparse
 import chardet
-
-
-# Configure logging
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
+from pipeline import logger
+from pipeline import FileUtils
 
 def check_encoding(file_path) -> dict:
     """
@@ -24,14 +21,14 @@ def check_encoding(file_path) -> dict:
     result = {}
 
     if not os.path.isfile(file_path):
-        logging.error("Error: The file %s does not exist.", file_path)
+        logger.error("Error: The file %s does not exist.", file_path)
         result = {"error": "File not found"}
 
     try:
         # Check file size to avoid processing excessively large files
         file_size = os.path.getsize(file_path)
         if file_size > 10 * 1024 * 1024:  # 10 MB limit
-            logging.error("Error: The file %s is too large to process.", file_path)
+            logger.error("Error: The file %s is too large to process.", file_path)
             result = {"error": "File too large"}
 
         with open(file_path, 'rb') as f:
@@ -40,13 +37,13 @@ def check_encoding(file_path) -> dict:
                 raw_data.extend(chunk)
         result = chardet.detect(raw_data)
     except FileNotFoundError:
-        logging.error("Error: The file %s was not found.", file_path)
+        logger.error("Error: The file %s was not found.", file_path)
         result = {"error": "File not found"}
     except PermissionError:
-        logging.error("Error: Permission denied for file %s.", file_path)
+        logger.error("Error: Permission denied for file %s.", file_path)
         result = {"error": "Permission denied"}
     except OSError as e:
-        logging.error("OS error occurred: %s", e)
+        logger.error("OS error occurred: %s", e)
         result = {"error": str(e)}
 
     return result
@@ -55,7 +52,14 @@ def main(files_to_check):
     """ Main function to check the encoding of files. """
     for file_path in files_to_check:
         result = check_encoding(file_path)
-        logging.info("%s: %s", file_path, result)
+        logger.info("%s: %s", file_path, result)
+
+        positions = FileUtils.find_non_ascii_bytes(file_path)
+        if positions:
+            logger.info("Non-ASCII bytes found in file: %s", file_path)
+            logger.info(positions)
+            FileUtils.clean_non_ascii_positions(file_path, positions)
+
 
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description="Check the encoding of files.")
diff --git a/nmap_project/run.py b/nmap_project/run.py
index 012d1cf..8d9b059 100644
--- a/nmap_project/run.py
+++ b/nmap_project/run.py
@@ -3,182 +3,268 @@ This is the main file that runs the Nmap Port Scanner Project.
 """
 
 import datetime
-import json
 import secrets
-import sys
 from pprint import pprint
-from pipeline import PipelineUtils, ChatbotUtils, logger, NmapScanner
+from pipeline import PipelineUtils, ChatbotUtils, NmapScanner, SearchSploit
+
+
+class NmapPortScannerProject:
+    """
+    The Nmap Port Scanner Project class that orchestrates the project.
+    """
+
+    def __init__(self, nmap_options, command=None):
+        self.nmap_options = nmap_options
+        self.command = command
+        self.args = self.prepare_args()
+        self.ip_addresses = [nmap_options['target']]
+        self.chatbot = None
+
+    def display_welcome_message(self):
+        """
+        Displays the welcome message with the current date and time.
+
+        Parameters:
+        None
+
+        Returns:
+        None
+        """
+        print("\n\nWelcome to the Nmap Port Scanner Project!\n\n")
+        print("Today's date and time: ", datetime.datetime.now(), " GMT.\n\n")
+
+    def prepare_args(self):
+        """
+        Prepares and returns the command line arguments for the pipeline.
+
+        Parameters:
+        None
+
+        Returns:
+        args: Namespace object containing the command line arguments.
+        """
+        args = PipelineUtils.get_args()
+        args.type = "json"
+        args.model = "lmstudio"
+        args.path = "nmap_project/documentation.json"
+        args.system_prompt_template = (
+            "You are a professional penetration testing expert."
+            "You must scan host of provided IP addresses for vulnerabilities."
+            "You must find ways to exploit these vulnerabilities."
+            "If methods fail, you must suggest alternative methods."
+            "You must write shell commands that perform these tasks."
+            "Format your response as a JSON object containing a list of commands."
+            "The JSON object should have a key 'commands' which maps to a list of objects."
+            "Exclude any additional text or information from your response."
+        )
+        args.output_type = "json"
+        args.collection_name = secrets.token_hex(16)
+        return args
+
+    def scan_ip_address(self):
+        """
+        Scans a provided IP address and returns the results.
+
+        Parameters:
+        None
+
+        Returns:
+        result (dict): The result of the Nmap scan.
+        """
+        nmap_scanner = NmapScanner(**self.nmap_options)
+        if self.command:
+            nmap_scanner.run_command(self.command)
+        else:
+            nmap_scanner.run_nmap()
+        nmap_scanner.parse_output()
+        result = nmap_scanner.get_parsed_data()
+        pprint(nmap_scanner.get_output())
+        pprint(result)
+        return result
+
+    def process_ports(self, result):
+        """
+        Processes the scanned ports and searches for exploits.
+
+        Parameters:
+        result (dict): The result of the Nmap scan.
+
+        Returns:
+        list: A list of options dictionaries containing port details.
+        """
+        options_list = []
+        for port in result['ports']:
+            options = {
+                "IP Address": self.nmap_options['target'],
+                "Port Number": port['port'],
+                "Service Name": port['service'],
+                "Version": port['version'],
+                "OS": result['os_info']
+            }
+            options_list.append(options)
+        return options_list
+
+    def search_exploits(self, version):
+        """
+        Searches for exploits based on the service version.
+
+        Parameters:
+        version (str): The version of the service being scanned.
+
+        Returns:
+        search_results (list): A list of search results from SearchSploit.
+        """
+        ss = SearchSploit()
+        search_results = ss.search([version])
+        pprint(search_results)
+        return search_results
+
+    def handle_chatbot(self, info, version):
+        """
+        Handles the chatbot interaction for vulnerability exploitation.
+
+        Parameters:
+        info (str): JSON formatted string with information about the target.
+        version (str): The version of the service being scanned.
+
+        Returns:
+        response (dict): The response from the chatbot.
+        """
+        self.args.collection_name = secrets.token_hex(16)
+        self.chatbot = PipelineUtils.create_chatbot(self.args)
+        response = self.chatbot.invoke(f"""
+        Information about the target: {info}.
+        What will be the best way to exploit vulnerability on target?
+        You must select right tool or tools from list to identify vulnerabilities of Version: '{version}' service.:
+        1: nmap
+        2: sqlmap
+        3: whatweb
+        4: dirb
+        5: gobuster
+        6: hydra
+        7: nikto
+        8: wpscan
+        If non of the tools are relevant, you may suggest other tools.
+        Respond in pure JSON format.
+        The response should follow this format:
+        {{
+            "commands": [
+                {{
+                    "method": ....,
+                    "description": ....,
+                    "tool": ....,
+                    "command": ...
+                }},
+                {{
+                    "method": ....,
+                    "description": ....,
+                    "tool": ....,
+                    "command": ...
+                }},
+                etc...
+            ]
+        }}
+        """)
+        parsed_response = ChatbotUtils.parse_json(response)
+        pprint(parsed_response)
+        self.chatbot.clear_chat_history()
+        return parsed_response
+
+    def handle_chatbot_vulnerability(self, info):
+        """
+        Handles the chatbot interaction for suggesting vulnerability proof of concept methods.
+
+        Parameters:
+        info (str): JSON formatted string with information about the target.
+
+        Returns:
+        response (dict): The response from the chatbot.
+        """
+        self.args.collection_name = secrets.token_hex(16)
+        self.chatbot = PipelineUtils.create_chatbot(self.args)
+        response = self.chatbot.invoke(f"""
+        You must suggest vulnerability proof of concept method.
+        Information about the target: {info}.
+        The installed tools at the moment are:
+        - nmap
+        - sqlmap
+        - whatweb
+        - dirb
+        - gobuster
+        - hydra
+        - nikto
+        - wpscan
+        - ncat
+        - hashcat
+        - john
+        - searchsploit
+        You must choose the tools which are relevant to target.
+        You may suggest tools that are not in the list but still relevant to target.
+        Respond in pure JSON format.
+        The JSON object should have a key 'commands' which maps to a list of objects.
+        Each object should have the following keys:
+        - 'method': The suggested pentesting method
+        - 'description': A description of the suggested pentesting method
+        - 'tool': The tool used to perform the pentesting method
+        - 'command': The tool command including the parameters and target and any other necessary information
+        The response should follow this format:
+        {{
+            "commands": [
+                {{
+                    "method": ....,
+                    "description": ....,
+                    "tool": ....,
+                    "command": ...
+                }},
+                {{
+                    "method": ....,
+                    "description": ....,
+                    "tool": ....,
+                    "command": ...
+                }},
+                etc...
+            ]
+        }}
+        """)
+        parsed_response = ChatbotUtils.parse_json(response)
+        pprint(parsed_response)
+        self.chatbot.clear_chat_history()
+        return parsed_response
+
+    def run(self):
+        """
+        The main function that orchestrates the Nmap Port Scanner Project.
+
+        Parameters:
+        None
+
+        Returns:
+        None
+        """
+        self.display_welcome_message()
+        scan_result = self.scan_ip_address()
+        options_list = self.process_ports(scan_result)
+        for options in options_list:
+            # info = json.dumps(options, indent=4)
+            self.search_exploits(options["Version"])
+            # self.handle_chatbot(info, options["Version"])
+            # self.handle_chatbot_vulnerability(info)
 
 
 def main():
     """
-    The main function.
+
     """
-    # write the date and the time of the conversation
-    print("\n\nWelcome to the Nmap Port Scanner Project!\n\n")
-    print("Today's date and time: ", datetime.datetime.now(), " GMT.\n\n")
-
-    args = PipelineUtils.get_args()
-    args.type = "json"
-    args.model = "lmstudio"
-    args.path = "nmap_project/documentation.json"
-
-    ip_addresses = [
-        '172.28.128.3',
-        # '192.168.56.4'
-    ]
-
-    args.system_prompt_template = (
-        "You are a professional peneteration testing expert."
-        "You must scan host of provided IP addresses for vulnerabilies."
-        "You must find ways to exploit these vulnerabilities."
-        "If methods fails, you must suggest alternative methods."
-        "You must write shell commands that perform these tasks."
-        "Format your response as a JSON object containing a list of commands."
-        "The JSON object should have a key 'commands' which maps to a list of objects."
-        "Exclude any additional text or information from your response."
-    )
-
-    args.output_type = "json"
-    args.collection_name = secrets.token_hex(16)
-    chatbot = PipelineUtils.create_chatbot(args)
-
-    try:
-        for ip_address in ip_addresses:
-            response = chatbot.invoke(f"""
-            Write the one command for namp scanning of all the ports -p-, services, version of the services and the OS type and version on Ip Addresses : ({ip_address}).
-            the response should resemble the following format:
-            {{
-                "commands": [
-                    {{
-                        "command": "nmap [the necessary flags or scripts] {ip_address}"
-                        "ports": "[if needed: string of ports seperated by comma or hyphen|None]",
-                        "flags": "[string of flags]",
-                        "target": "{ip_address}",
-                        "firewall": "[if needed: true|false]",
-                        "script": "[if needed: {{script_name: script_path, ...}}|None]"
-                    }}
-                ]
-            }}
-            """)
-
-            response_json = ChatbotUtils.parse_json(response)
-
-            pprint(response_json)
-
-            # Zero out the path so that the chatbot doesn't try to read from it
-            args.path = None
-            # changing to simple chatbot
-            args.type = "chat"
-
-            for command in response_json['commands']:
-                logger.info(command['command'])
-                # command['firewall'] = True
-                command['flags'] += " -T5 "
-                nmap_scanner = NmapScanner(**command)
-                nmap_scanner.run_command(command['command'])
-                # nmap_scanner.run_nmap()
-                logger.info(nmap_scanner.parse_output())
-                logger.info("Nmap scan output:")
-                result = nmap_scanner.get_parsed_data()
-                pprint(nmap_scanner.get_output())
-                pprint(result)
-
-
-
-                for port in result['ports']:
-                    options = {
-                        "IP Address": ip_address,
-                        "Port Number": port['port'],
-                        "Service Name": port['service'],
-                        "Version": port['version'],
-                        "OS": result['os_info']
-                    }
-                    logger.info(options)
-                    info = json.dumps(options, indent=4)
-
-                    args.collection_name = secrets.token_hex(16)
-                    _chatbot = PipelineUtils.create_chatbot(args)
-                    response = _chatbot.invoke(f"""
-                    What will be the best way to exploit the vulnerability on the target?
-                    Information about the target: {info}.
-                    Sugget necessary tools and commands to exploit the vulnerability.
-                    Respond in pure JSON format.
-                    The response should follow this format:
-                    {{
-                        "commands": [
-                            {{
-                                "method": ....,
-                                "description": ....,
-                                "tool": ....,
-                                "command": ...
-                            }},
-                            {{
-                                "method": ....,
-                                "description": ....,
-                                "tool": ....,
-                                "command": ...
-                            }},
-                            etc...
-                        ]
-                    }}
-                    """)
-                    pprint(ChatbotUtils.parse_json(response))
-                    _chatbot.clear_chat_history()
-                    sys.exit()
-                    continue
-
-
-
-                    args.collection_name = secrets.token_hex(16)
-                    _chatbot = PipelineUtils.create_chatbot(args)
-                    response = _chatbot.invoke(f"""
-                    You must suggest vulnerability proof of concept method.
-                    Information about the target: {info}.
-                    The installed tools at the moment are:
-                    - nmap
-                    - sqlmap
-                    - whatweb
-                    - dirb
-                    - gobuster
-                    - hydra
-                    - ncat
-                    - hashcat
-                    - john
-                    - searchsploit
-                    You must choose the tools which are relevant to target.
-                    You may suggest tools that are not in the list but still relevant to target.
-                    Respond in pure JSON format.
-                    The JSON object should have a key 'commands' which maps to a list of objects.
-                    Each object should have the following keys:
-                    - 'method': The suggested pentesting method
-                    - 'description': A description of the suggested pentesting method
-                    - 'tool': The tool used to perform the pentesting method
-                    - 'command': The tool command including the parameters and target and any other necessary information
-                    The response should follow this format:
-                    {{
-                        "commands": [
-                            {{
-                                "method": ....,
-                                "description": ....,
-                                "tool": ....,
-                                "command": ...
-                            }},
-                            {{
-                                "method": ....,
-                                "description": ....,
-                                "tool": ....,
-                                "command": ...
-                            }},
-                            etc...
-                        ]
-                    }}
-                    """)
-                    pprint(ChatbotUtils.parse_json(response))
-                    _chatbot.clear_chat_history()
-
-    except KeyboardInterrupt:
-        print("\n\nGoodbye!\n\n")
+    nmap_options = {
+        'target': '172.28.128.3',
+        'firewall': False,
+        'flags': '-sV -O -T5',
+        'ports': None,
+        'script': None
+    }
+    command = None  # or provide a specific nmap command here if needed
+    project = NmapPortScannerProject(nmap_options, command)
+    project.run()
 
 
 if __name__ == "__main__":
diff --git a/pipeline/__init__.py b/pipeline/__init__.py
index c4d5601..422dcac 100644
--- a/pipeline/__init__.py
+++ b/pipeline/__init__.py
@@ -4,18 +4,30 @@ author: Babak Bandpey
 Description: The pipeline module provides a high-level interface for running a chatbot.
 """
 
+__version__ = '0.5.0'
+__author__ = 'Babak Bandpey <bb@cocode.dk>'
+
+# Essential imports
 from .config import OPENAI_API_KEY
 from .chatbot import Chatbot
+
+# Utility imports
+from .pipeline_utils import PipelineUtils
+from .file_utils import FileUtils
+from .chatbot_utils import ChatbotUtils
+from .logger import logger
+
+# RAG (Retrieval-Augmented Generation) imports
 from .txt_rag import TxtRAG
 from .web_rag import WebRAG
 from .py_rag import PyRAG
 from .pdf_rag import PdfRAG
 from .json_rag import JsonRAG
-from .pipeline_utils import PipelineUtils
-from .file_utils import FileUtils
-from .chatbot_utils import ChatbotUtils
-from .logger import logger
-from .nmap_scanner import NmapScanner
+from .md_rag import MdRAG
+
+# Nmap project imports
+from .nmap_project.nmap_scanner import NmapScanner
+from .nmap_project.searchsploit import SearchSploit
 
 __all__ = [
     'OPENAI_API_KEY',
@@ -28,9 +40,8 @@ __all__ = [
     'PyRAG',
     'PdfRAG',
     'JsonRAG',
+    'MdRAG',
     'logger',
-    'NmapScanner'
+    'NmapScanner',
+    'SearchSploit'
 ]
-
-__version__ = '0.5.0'
-__author__ = 'Babak Bandpey <bb@cocode.dk>'
diff --git a/pipeline/config.py b/pipeline/config.py
index bc371b1..3e221bc 100644
--- a/pipeline/config.py
+++ b/pipeline/config.py
@@ -20,7 +20,7 @@ load_dotenv()
 OPENAI_API_KEY = None
 AZURE_OPENAI_ENDPOINT = None
 AZURE_OPENAI_API_KEY_1 = None
-LOGGING_LEVEL = logging.INFO
+LOGGING_LEVEL = logging.DEBUG
 
 logging.basicConfig(
     level=LOGGING_LEVEL,
diff --git a/pipeline/file_utils.py b/pipeline/file_utils.py
index bfd5c00..b7cf989 100644
--- a/pipeline/file_utils.py
+++ b/pipeline/file_utils.py
@@ -12,7 +12,7 @@ class FileUtils:
         params: extension: The file extension to search for.
         params: exclude_dirs: Directories to exclude from the search.
         """
-        
+
         if exclude_dirs is None:
             exclude_dirs = [".env", ".git"]
 
@@ -91,21 +91,36 @@ class FileUtils:
             logger.error("Error: %s", e)
 
     @staticmethod
-    def clean_non_ascii_bytes(file_path, replacement_byte=b' '):
+    def clean_non_ascii_positions(file_path, positions, replacement_byte=b' '):
         """
-        Cleans non-ASCII bytes from a text file.
+        Cleans non-ASCII bytes from a text file at specified positions.
         params: file_path: The path to the text file.
+        params: positions: A list of tuples with positions and values of non-ASCII bytes.
         params: replacement_byte: The byte to replace non-ASCII bytes with.
         """
         try:
+            if len(replacement_byte) != 1:
+                raise ValueError("replacement_byte must be a single byte.")
+
+            replacement_byte_int = replacement_byte[0]  # Get the integer value of the replacement byte
+
             with open(file_path, 'rb') as file:
-                data = file.read()
-            cleaned_data = bytearray(replacement_byte if byte > 0x7F else byte for byte in data)
+                data = bytearray(file.read())
+
+            for pos, _ in positions:
+                if pos < len(data):
+                    data[pos] = replacement_byte_int
+
             with open(file_path, 'wb') as file:
-                file.write(cleaned_data)
+                file.write(data)
+
             logger.info("Non-ASCII bytes cleaned from file: %s", file_path)
         except FileNotFoundError as e:
-            logger.error("Error: %s", e)
+            logger.error("File not found: %s", e)
+        except ValueError as e:
+            logger.error("Value error: %s", e)
+        except Exception as e:
+            logger.error("An error occurred: %s", e)
 
     @staticmethod
     def find_non_ascii_bytes(file_path):
diff --git a/pipeline/logger.py b/pipeline/logger.py
index 1c814f7..1ff9e1c 100644
--- a/pipeline/logger.py
+++ b/pipeline/logger.py
@@ -1,4 +1,6 @@
-
+"""
+A module for logging messages with color based on the log level.
+"""
 
 import inspect
 import os
@@ -8,8 +10,6 @@ from .config import LOGGING_LEVEL
 def get_importing_file_name():
     """ Get the name of the file that imports this module. """
     stack = inspect.stack()
-    # stack[1] is the caller of the current function
-    # stack[2] is the caller of the caller of the current function
     frame = stack[2]
     module = inspect.getmodule(frame[0])
     if module:
@@ -47,22 +47,26 @@ class ColoredFormatter(logging.Formatter):
         Returns:
             str: The formatted log message with color added.
         """
-        # Get the original message
         message = super().format(record)
-
-        # Apply color based on the log level
         color = self.COLORS.get(record.levelname, self.RESET)
         message = f"{color}{record.levelname}: {message}{self.RESET}"
-
         return message
 
-# Create a handler
-handler = logging.StreamHandler()
-# Set the custom formatter
-formatter = ColoredFormatter('%(asctime)s - %(filename)s:%(lineno)d - %(message)s')
-handler.setFormatter(formatter)
+def initialize_logger() -> logging.Logger:
+    """ Initialize the logger with a custom handler and formatter. """
+    handler = logging.StreamHandler()
+    formatter = ColoredFormatter('%(asctime)s - %(filename)s:%(lineno)d - %(message)s')
+    handler.setFormatter(formatter)
+
+    # Get the name of the importing file
+    importing_file_name = get_importing_file_name()
+
+    # Set up the logger
+    l = logging.getLogger(importing_file_name)
+    l.setLevel(LOGGING_LEVEL)
+    l.addHandler(handler)
+
+    return l
 
-# Set up the root logger
-logger = logging.getLogger(get_importing_file_name())
-logger.setLevel(LOGGING_LEVEL)
-logger.addHandler(handler)
+# Initialize the logger and expose it as a module-level variable
+logger = initialize_logger()
diff --git a/pipeline/nmap_scanner.py b/pipeline/nmap_scanner.py
deleted file mode 100644
index f67b325..0000000
--- a/pipeline/nmap_scanner.py
+++ /dev/null
@@ -1,147 +0,0 @@
-"""
-This module contains the NmapScanner class, which represents an Nmap scanner.
-
-The NmapScanner class provides methods to run an Nmap scan on a target IP address or hostname,
-parse the scan output, and extract relevant information.
-
-Example usage:
-    target = "192.168.56.4"
-    scanner = NmapScanner(target)
-    scanner.run_nmap() or scanner.run_command("nmap -sV -p 22,80 -O 10.0.10.10")
-    scanner.parse_output()
-"""
-
-import subprocess
-import re
-from .chatbot_utils import logger
-from pprint import pprint
-
-class NmapScanner:
-    """
-    A class that represents an Nmap scanner.
-
-    Attributes:
-        target (str): The target IP address or hostname to scan.
-        nmap_output (str): The output of the Nmap scan.
-        parsed_data (dict): Parsed data from the Nmap scan.
-
-    Methods:
-        run_nmap(): Runs the Nmap scan.
-        run_command(command: str): Runs a command in the shell.
-        parse_output(): Parses the Nmap scan output.
-        get_parsed_data(): Returns the parsed data from the Nmap scan.
-    """
-    def __init__(self, **kwargs):
-        if 'target' not in kwargs:
-            logger.error("Target IP address or hostname is required. kwargs: %s", kwargs)
-            raise ValueError("Target IP address or hostname is required.")
-
-        self._kwargs = kwargs
-        self.nmap_output = ''
-        self.parsed_data = {}
-
-
-    def __getattr__(self, name):
-        """
-        Returns the value of the specified attribute.
-        """
-        attributes = {
-            "target": lambda: self._kwargs.get("target"),
-            "flags": lambda: self._kwargs.get("flags", ""),
-            "ports": lambda: f" -p {self._kwargs['ports']}" if self._kwargs.get("ports") and self._kwargs['ports'] != '-p-' else "-p-",
-            "firewall": lambda: " -Pn " if self._kwargs.get("firewall") else "",
-            "script": lambda: f" --script {self._kwargs['script']}" if self._kwargs.get("script") else ""
-        }
-
-        if name in attributes:
-            return attributes[name]()
-
-        raise AttributeError(f"The 'NmapScanner' object has no attribute '{name}'")
-
-
-    def run_nmap(self):
-        """
-        Runs an Nmap scan on the target.
-
-        Returns:
-            str: The output of the Nmap scan.
-        """
-        command = f"nmap {self.flags} {self.ports} {self.script} {self.firewall} {self.target}"
-        return self.run_command(command)
-
-
-    def run_command(self, command):
-        """
-        Runs a command in the shell.
-        param command: The command to run.
-        """
-
-        logger.info("Running Nmap command: %s", command)
-
-        try:
-            with subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) as process:
-                output, error = process.communicate()
-                if process.returncode != 0:
-                    logger.error("Error running nmap: %s", error)
-                    return None
-
-            self.nmap_output = output
-            return self
-        except Exception as e:
-            logger.error("Error running nmap: %s", str(e))
-
-
-    def parse_output(self):
-        """
-        Parses the Nmap scan output and extracts relevant information.
-        """
-        host_regex = re.compile(r'Nmap scan report for ([\d\.]+)')
-        port_regex = re.compile(r'(\d+/\w+)\s+(\w+)\s+(\w+)\s+(.+)')
-        mac_regex = re.compile(r'MAC Address: ([0-9A-F:]+) \((.+)\)')
-        service_info_regex = re.compile(r'Service Info: OSs: (.+); CPE: (.+)')
-
-        host_match = host_regex.search(self.nmap_output)
-        host_ip = host_match.group(1) if host_match else None
-
-        ports = []
-        for port_match in port_regex.finditer(self.nmap_output):
-            port_info = {
-                'port': port_match.group(1),
-                'state': port_match.group(2),
-                'service': port_match.group(3),
-                'version': port_match.group(4)
-            }
-            ports.append(port_info)
-
-        mac_match = mac_regex.search(self.nmap_output)
-        mac_address = mac_match.group(1) if mac_match else None
-        mac_vendor = mac_match.group(2) if mac_match else None
-
-        service_info_match = service_info_regex.search(self.nmap_output)
-        os_info = service_info_match.group(1) if service_info_match else None
-        cpe_info = service_info_match.group(2) if service_info_match else None
-
-        self.parsed_data = {
-            'host_ip': host_ip,
-            'ports': ports,
-            'mac_address': mac_address,
-            'mac_vendor': mac_vendor,
-            'os_info': os_info,
-            'cpe_info': cpe_info
-        }
-
-        return self
-
-
-    def get_output(self):
-        """
-        Returns the output of the Nmap scan.
-        """
-        return self.nmap_output
-
-
-    def get_parsed_data(self):
-        """
-        Returns the parsed data from the Nmap scan.
-        """
-        return self.parsed_data
diff --git a/pipeline/pipeline_utils.py b/pipeline/pipeline_utils.py
index d34f5f3..7c15c56 100644
--- a/pipeline/pipeline_utils.py
+++ b/pipeline/pipeline_utils.py
@@ -124,6 +124,13 @@ class PipelineUtils():
             help="The collection name",
             default=secrets.token_hex(16))
 
+        parser.add_argument(
+            "--auto_clean",
+            action="store_true",
+            required=False,
+            help="Auto clean the non ascii characters",
+            default=False)
+
         return parser.parse_args()
 
 
@@ -280,38 +287,15 @@ class PipelineUtils():
 
         base_url, openai_api_key = PipelineUtils.get_base_url_and_api_key(args)
 
-        if hasattr(args, 'collection_name') and args.collection_name is not None:
-            collection_name = args.collection_name
-        else:
-            collection_name = None
-
-        if hasattr(args, 'git_url') and args.git_url is not None:
-            git_url = args.git_url
-        else:
-            git_url = None
-
-        if hasattr(args, 'path') and args.path is not None:
-            path = args.path
-        else:
-            path = None
-
-        if hasattr(args, 'url') and args.url is not None:
-            url = args.url
-        else:
-            url = None
-
-        return {
-            "base_url": base_url,
-            "model": args.model,
-            "openai_api_key": openai_api_key,
-            "collection_name": collection_name,
-            "git_url": git_url,
-            "path": path,
-            "url": url,
-            "prompt": args.prompt,
-            "system_prompt_template": args.system_prompt_template,
-            "output_type": args.output_type
-        }
+        _kwargs = {}
+
+        for key, value in vars(args).items():
+            _kwargs[key] = value
+
+        _kwargs["base_url"] = base_url
+        _kwargs["openai_api_key"] = openai_api_key
+
+        return _kwargs
 
 
     @staticmethod
diff --git a/pipeline/rag_factory.py b/pipeline/rag_factory.py
index ea005be..96b5815 100644
--- a/pipeline/rag_factory.py
+++ b/pipeline/rag_factory.py
@@ -9,7 +9,8 @@ rag_mapping = {
     'py': ('pipeline.py_rag', 'PyRAG'),
     'web': ('pipeline.web_rag', 'WebRAG'),
     'pdf': ('pipeline.pdf_rag', 'PdfRAG'),
-    'json': ('pipeline.json_rag', 'JsonRAG')
+    'json': ('pipeline.json_rag', 'JsonRAG'),
+    'md': ('pipeline.md_rag', 'MdRAG'),
 }
 
 class RAGFactory:
diff --git a/pipeline/retrieval.py b/pipeline/retrieval.py
index d0b950e..1940be8 100644
--- a/pipeline/retrieval.py
+++ b/pipeline/retrieval.py
@@ -159,7 +159,7 @@ class Retrieval(Pipeline):
                 self.logger.warning("Non-ASCII bytes found in file: %s", file_path)
                 self.logger.warning(non_ascii_positions)
                 if self.auto_clean:
-                    FileUtils.clean_non_ascii_bytes(file_path)
+                    FileUtils.clean_non_ascii_positions(file_path, non_ascii_positions)
                 else:
                     raise ValueError(
                         f"Non-ASCII bytes found in file: {file_path}."
@@ -170,7 +170,7 @@ class Retrieval(Pipeline):
             raise ValueError(f"Invalid path: {self.path}. No such file or directory.")
         if os.path.isdir(self.path):
             for file in os.listdir(self.path):
-                if file.endswith(".txt"):
+                if file.endswith(".txt") or file.endswith(".md"):
                     file_path = os.path.join(self.path, file)
                     detect_and_clean(file_path)
         else:
diff --git a/pipeline/txt_rag.py b/pipeline/txt_rag.py
index 906f1a9..256c8e9 100644
--- a/pipeline/txt_rag.py
+++ b/pipeline/txt_rag.py
@@ -25,7 +25,6 @@ class TxtRAG(Retrieval):
         """
         super().__init__(**kwargs)
         self.path = kwargs.get('path', None)
-        self.auto_clean = kwargs.get('auto_clean', False)
         if not self.path:
             raise ValueError("The path parameter is required.")
         self.documents = []
diff --git a/requirements.txt b/requirements.txt
index 1d25ac5..5f96e31 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -129,6 +129,7 @@ typer
 typing-inspect
 typing_extensions
 ujson
+unstructured[md]
 urllib3
 uvicorn
 uvloop
diff --git a/scripts/push.py b/scripts/push.py
index ae30c6f..8f9ef4b 100644
--- a/scripts/push.py
+++ b/scripts/push.py
@@ -27,6 +27,7 @@ Note: This script assumes that the necessary dependencies are installed and
 import subprocess
 import sys
 import os
+import secrets
 from datetime import datetime
 from pipeline import PipelineUtils, ChatbotUtils, logger
 
@@ -98,6 +99,7 @@ def create_and_checkout_new_branch():
         run_command(["git", "checkout", "-b", new_branch_name])
         return new_branch_name
 
+
 def run_tests():
     """Run pytest and abort if tests fail."""
     logger.info("Running tests...")
@@ -109,121 +111,233 @@ def run_tests():
     logger.info("All tests passed.")
 
 
-def run_checks(chatbot):
+def run_pylint(file):
     """
-    Run checks before committing the changes.
-    params: chatbot: The chatbot object to interact with the AI model.
-    return: True if all checks pass, False otherwise.
+    Run pylint on a given file and return the result.
+    params: file: The file to run pylint on.
+    return: The output of pylint.
     """
+    try:
+        result = subprocess.run(['pylint', file], capture_output=True, text=True, check=True)
+        return result.stdout
+    except subprocess.CalledProcessError as e:
+        return e.output
+
 
-    security_check = chatbot.invoke(
-        "Confirm that the changes does not contain any sensitive information."
-    )
 
-    if security_check:
-        logger.info("Security check: %s", security_check)
-        response = input("Is the security check okay? (y/n): ").strip().lower()
-        if response == "n":
+def run_checks(args):
+    """
+    Run checks before committing the changes.
+    params: args: The arguments to pass to the chat
+    return: True if all checks pass, False otherwise.
+    """
+    try:
+        modified_files, moved_files, added_files, _ = get_changed_files()
+        if not (modified_files or moved_files or added_files):
+            logger.info("No changed, added, or moved files found.")
             return False
 
-    vulnerability_check = chatbot.invoke(
-        "Confirm that the changes does not introduce any security vulnerabilities."
-    )
+        all_files = list(modified_files) + list(moved_files.values()) + list(added_files)
 
-    if vulnerability_check:
-        logger.info("Vulnerability check: %s", vulnerability_check)
-        response = input("Is the vulnerability check okay? (y/n): ").strip().lower()
-        if response == "n":
-            return False
+        for file in all_files:
 
-    code_quality_check = chatbot.invoke(
-        "Confirm that the changes meet the code quality standards."
-    )
+            accepted_file_types = [".py", ".txt", ".json", ".md"]
+            if not any(file.endswith(file_type) for file_type in accepted_file_types):
+                logger.warning("Unsupported file type: %s. Skipping checks...", file)
+                continue
 
-    if code_quality_check:
-        logger.info("Code quality check: %s", code_quality_check)
-        response = input("Is the code quality check okay? (y/n): ").strip().lower()
-        if response == "n":
-            return False
+            # create chatbot based on file type
+            file_type = os.path.splitext(file)[1][1:]
+            args.type = file_type
+            args.path = file
+            args.collection_name = secrets.token_hex(16)
+            chatbot = PipelineUtils.create_chatbot(args)
 
-    pylint_check = chatbot.invoke(
-        "Confirm that the changes pass the pylint check."
-    )
+            security_check = chatbot.invoke(
+                f"Confirm that the changes do not contain any sensitive information in the file: {file}"
+            )
 
-    if pylint_check:
-        logger.info("Pylint check: %s", pylint_check)
-        response = input("Is the pylint check okay? (y/n): ").strip().lower()
-        if response == "n":
-            return False
+            if security_check:
+                logger.info("Security check for %s: %s", file, security_check)
+                response = input(f"Is the security check for {file} okay? (y/n): ").strip().lower()
+                if response == "n":
+                    return False
 
-    improvement_check = chatbot.invoke(
-        """
-        Write 1 suggestion for code improvement of the changes and format it as a JSON.
-        The JSON should contain the following keys
-        'path': 'The path of the file',
-        'line': 'The line number where the improvement is suggested',
-        'snippet': 'The code snippet where the improvement is suggested',
-        'suggestion': 'The suggestion for improvement'
-        'suggested_change': 'The suggested improved code snippet'
-        'function': 'The function name where the improvement is suggested if applicable'
-        """
-    )
-
-    if improvement_check:
-        logger.info(improvement_check)
-
-    response = input("Do you want to implement the improvement? (y/n): ").strip().lower()
-    if response == "y":
-        return False
+            vulnerability_check = chatbot.invoke(
+                f"Confirm that the changes do not introduce any security vulnerabilities in the file: {file}"
+            )
 
-    return True
+            if vulnerability_check:
+                logger.info("Vulnerability check for %s: %s", file, vulnerability_check)
+                response = input(f"Is the vulnerability check for {file} okay? (y/n): ").strip().lower()
+                if response == "n":
+                    return False
 
-def create_commit_message(chatbot):
-    """Create a commit message."""
-    logger.info("Running chatbot.py to generate commit message...")
-    try:
-        while True:
-            commit_message = chatbot.invoke(
-                """
-                Write a detailed commit message based on the provided context.
-                Write the title of the commit message in the first line.
-                Do not include any extra information in the
-                commit message such as code.
-                Format the commit message as JSON.
+            code_quality_check = chatbot.invoke(
+                f"Confirm that file meet the code quality standards in the file: {file}"
+            )
+
+            if code_quality_check:
+                logger.info("Code quality check for %s: %s", file, code_quality_check)
+                response = input(f"Is the code quality check for {file} okay? (y/n): ").strip().lower()
+                if response == "n":
+                    return False
+
+            pylint_check = run_pylint(file)
+            if pylint_check:
+                logger.info("Pylint check for %s: %s", file, pylint_check)
+                response = input(f"Is the pylint check for {file} okay? (y/n): ").strip().lower()
+                if response == "n":
+                    return False
+
+            improvement_check = chatbot.invoke(
+                f"""
+                Write 1 suggestion for code improvement of the changes in the file: {file} and format it as a JSON.
                 The JSON should contain the following keys:
-                'title': 'The title of the commit message',
-                'description': ['The description of the commit message as a list of sentences.'],
-                'type': 'The type of the commit message (e.g. feature, bugfix, etc.)',
+                'path': 'The path of the file',
+                'line': 'The line number where the improvement is suggested',
+                'snippet': 'The code snippet where the improvement is suggested',
+                'suggestion': 'The suggestion for improvement',
+                'suggested_change': 'The suggested improved code snippet',
+                'function': 'The function name where the improvement is suggested if applicable'
                 """
             )
 
-            if commit_message:
-                commit_message_json = ChatbotUtils.parse_json(commit_message)
-                if commit_message_json is None:
-                    logger.warning("Invalid JSON format. Truing again... CTRL+C to abort.")
-                    continue
-                commit_message = commit_message_json.get('title', 'No Title!')
-                commit_message += "\n\nDescription:\n"
-                description = commit_message_json.get('description', ['No Description!'])
-                for i, sentence in enumerate(description, start=1):
-                    commit_message += f"{i}. {sentence.strip()}.\n"
-                commit_message += f"\nType: {commit_message_json.get('type', 'No Type!')}"
-
-                logger.info("Generated commit message: %s", commit_message)
-                response = input("Is the commit message okay? (y/n): ").strip().lower()
-                if response == "y":
-                    with open("commit_message.txt", "w", encoding='utf-8') as commit_message_file:
-                        commit_message_file.write(commit_message)
-                    break
+            if improvement_check:
+                logger.info("Improvement suggestion for %s: %s", file, improvement_check)
+
+            response = input(f"Do you want to implement the improvement for {file}? (y/n): ").strip().lower()
+            if response == "y":
+                return False
+
+
+            chatbot.delete_collection()
+            chatbot.clear_chat_history()
 
         return True
 
-    except KeyboardInterrupt:
-        logger.error("Aborting commit.")
-    except ValueError as e:
-        logger.error("Error generating commit message: %s", e)
+    except subprocess.CalledProcessError as e:
+        logger.error("Error running git status: %s", e)
+        return False
+    except Exception as e:
+        logger.error("An error occurred: %s", e)
+        return False
+
+def get_changed_files() -> tuple:
+    """
+    Get the list of changed, added, or moved files.
+    return: A tuple containing the modified files, moved files, and added files.
+    """
+    try:
+        result = subprocess.run(['git', 'status', '-M', '--porcelain'], capture_output=True, text=True, check=True)
+    except subprocess.CalledProcessError as e:
+        logger.error("Error running git status: %s", e)
+        raise e
+
+    modified_files = set()
+    added_files = set()
+    moved_files = {}
+    deleted_files = set()
+
+    for line in result.stdout.splitlines():
+        status, file_path = line[:2], line[3:]
+        if status == 'M ':
+            modified_files.add(file_path)
+        elif status == 'A ':
+            added_files.add(file_path)
+        elif status.startswith('R'):
+            old_file, new_file = file_path.split(' -> ')
+            moved_files[old_file] = new_file
+        elif status == 'D ':
+            deleted_files.add(file_path)
+
+    return modified_files, moved_files, added_files, deleted_files
+
+def generate_commit_message(chatbot, context):
+    """
+    Generate a commit message using the chatbot based on the provided context.
+    params: chatbot: The chatbot object to interact with the AI model.
+    params: context: The context for generating the commit message.
+    """
+    while True:
+        commit_message = chatbot.invoke(
+            f"""
+            Write a detailed commit message based on the provided context.
+            {context}
+            Write the title of the commit message in the first line.
+            Do not include any extra information in the
+            commit message such as code.
+            Format the commit message as JSON.
+            The JSON should contain the following keys:
+            'title': 'The title of the commit message',
+            'description': ['The description of the commit message as a list of sentences.'],
+            'type': 'The type of the commit message (e.g. feature, bugfix, etc.)',
+            """
+        )
+
+        if commit_message:
+            commit_message_json = ChatbotUtils.parse_json(commit_message)
+            if commit_message_json is None:
+                logger.warning("Invalid JSON format. Trying again... CTRL+C to abort.")
+                continue
+
+            title = commit_message_json.get('title', 'No Title!')
+            description = commit_message_json.get('description', ['No Description!'])
+            commit_type = commit_message_json.get('type', 'No Type!')
+
+            commit_message_formatted = f"{title}\n\nDescription:\n"
+            for i, sentence in enumerate(description, start=1):
+                commit_message_formatted += f"{i}. {sentence.strip()}.\n"
+            commit_message_formatted += f"\nType: {commit_type}\n"
+
+            return commit_message_formatted
+
+def create_commit_message(chatbot):
+    """
+    Create a commit message.
+    params: chatbot: The chatbot object to interact with the AI model.
+    """
+    logger.info("Running chatbot.py to generate commit message...")
+
+    try:
+        modified_files, moved_files, added_files, deleted_files = get_changed_files()
+        if not (modified_files or moved_files or added_files):
+            logger.info("No changed, added, or moved files found.")
+            return False
+
+        consolidated_commit_message = ""
+
+        for file in modified_files:
+            context = f"The file that has been changed is: {file}"
+            commit_message_formatted = generate_commit_message(chatbot, context)
+            consolidated_commit_message += commit_message_formatted + "\n"
+
+        for old_file, new_file in moved_files.items():
+            context = f"The file that has been moved is from: {old_file} to {new_file}"
+            commit_message_formatted = generate_commit_message(chatbot, context)
+            consolidated_commit_message += commit_message_formatted + "\n"
+
+        for file in added_files:
+            context = f"The file that has been added is: {file}"
+            commit_message_formatted = generate_commit_message(chatbot, context)
+            consolidated_commit_message += commit_message_formatted + "\n"
+
+        for file in deleted_files:
+            context = f"The file that has been deleted is: {file}"
+            commit_message_formatted = generate_commit_message(chatbot, context)
+            consolidated_commit_message += commit_message_formatted + "\n"
+
+        logger.info("Generated consolidated commit message: %s", consolidated_commit_message)
+        response = input("Is the consolidated commit message okay? (y/n): ").strip().lower()
+        if response == "y":
+            with open("commit_message.txt", "w", encoding='utf-8') as commit_message_file:
+                commit_message_file.write(consolidated_commit_message)
+            return True
+
+    except Exception as e:
+        logger.error("An error occurred: %s", str(e))
+        return False
 
-    return False
 
 def cleanup():
     """
@@ -278,10 +392,11 @@ def main():
     args = PipelineUtils.get_args()
     args.type = "txt"
     args.path = "diff.txt"
+    args.collection_name = secrets.token_hex(16)
     chatbot = PipelineUtils.create_chatbot(args)
 
     # Step 7: Run checks before committing the changes
-    if not run_checks(chatbot) or not create_commit_message(chatbot):
+    if not run_checks(args) or not create_commit_message(chatbot):
         logger.info("Aborting commit.")
         unstage_changes()
         cleanup()
@@ -304,6 +419,8 @@ def main():
     logger.info("Setting upstream branch to %s and pushing changes...", branch_name)
     run_command(["git", "push", "--set-upstream", "origin", branch_name])
 
+    chatbot.delete_collection()
+    chatbot.clear_chat_history()
 
 if __name__ == "__main__":
     main()
diff --git a/tests/test_chatbot.py b/tests/test_chatbot.py
index fae98cf..7e5e15e 100644
--- a/tests/test_chatbot.py
+++ b/tests/test_chatbot.py
@@ -12,7 +12,8 @@ def chatbot():
     """
     return Chatbot(
         base_url="https://api.openai.com/v1/",
-        model="gpt-4o", openai_api_key=OPENAI_API_KEY
+        model="gpt-4o",
+        openai_api_key=OPENAI_API_KEY
     )
 
 def test_chatbot_initialization(chatbot):
