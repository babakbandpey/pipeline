"""

"""


from datetime import datetime
from pipeline import PipelineUtils, ChatbotUtils, logger, FileUtils
import subprocess
import sys


def split_diff_by_file(diff_path: str) -> list:
    """
    Splits the diff content into sections, one for each file.
    param: diff_content: The diff content to split.
    return: A list of sections, each containing the diff content for a single file.
    """

    diff_content = FileUtils.read_file(diff_path)

    sections = []
    current_section = []

    for line in diff_content.splitlines():
        if line.startswith('diff --git'):
            if current_section:
                sections.append('\n'.join(current_section))
                current_section = []
        current_section.append(line)

    if current_section:
        sections.append('\n'.join(current_section))

    return sections


def create_commit_message(chatbot) -> str:
    """
    Create a commit message using the chatbot.
    params: chatbot: The chatbot object to interact with the AI model.
    return: The generated commit message or False if the process is aborted.
    """
    logger.info("Running chatbot to generate commit message...")
    try:
        commit_message = chatbot.invoke(
            (
                "Write a detailed commit message based on the provided content. "
                "Format the commit message as JSON with the keys: "
                "'title', 'description' (list of sentences), and 'type' (e.g., feature, bugfix)."
            )
        )

        logger.info("Commit message generated by chatbot: %s", commit_message)

        if commit_message:
            commit_message_json = ChatbotUtils.parse_json(commit_message)
            if commit_message_json is None:
                logger.warning("Invalid JSON format. Trying again... Press CTRL+C to abort.")
                return None
            commit_message = commit_message_json.get('title', 'No Title!')
            commit_message += "\n\nDescription:\n"
            description = commit_message_json.get('description', ['No Description!'])
            for i, sentence in enumerate(description, start=1):
                sentence = sentence.strip()
                # Check if the sentence already ends with punctuation
                if not sentence.endswith(('.', '!', '?')):
                    sentence += '.'
                commit_message += f"{i}. {sentence}\n"
            commit_message += f"\nType: {commit_message_json.get('type', 'No Type!')}"

            logger.info("Generated commit message: %s", commit_message)

        return commit_message
    except KeyboardInterrupt:
        logger.error("Aborting commit.")
    except ValueError as e:
        logger.error("Error generating commit message: %s", str(e))

    return False


def run_pytest() -> bool:
    """
    Executes pytest and returns True if all tests pass, False otherwise.
    """
    logger.info("Running pytest...")
    try:
        # Execute pytest and capture output
        result = subprocess.run(['pytest'], capture_output=True, text=True)

        if result.returncode == 0:
            logger.info("All tests passed successfully.")
            return True
        else:
            logger.error("Pytest failed with the following output:\n%s", result.stdout)
            logger.error("Pytest stderr:\n%s", result.stderr)
            return False
    except FileNotFoundError:
        logger.error("Pytest is not installed or not found in the PATH.")
        return False
    except Exception as e:
        logger.error("An unexpected error occurred while running pytest: %s", str(e))
        return False


def create_commit_message_file(commit_message: str, file_path: str = "/app/commit/commit_message.txt"):
    """
    Writes the commit message to a specified file.
    params:
        commit_message: The commit message to write.
        file_path: The path where the commit message file will be created.
    """
    try:
        FileUtils.write_to_file(file_path, commit_message)
        logger.info("Commit message written to %s successfully.", file_path)
    except Exception as e:
        logger.error("Failed to write commit message to: %s", file_path)
        sys.exit(1)


def main():
    """Main function to generate commit message."""

    # Step 1: Run pytest before generating commit message
    if not run_pytest():
        logger.error("Tests failed. Aborting commit message generation.")
        sys.exit(1)  # Exit the script with a non-zero status to indicate failure

    # Step 2: Create chatbot to run checks and generate commit message
    args = PipelineUtils.get_args()
    args.type = "txt"
    result = split_diff_by_file("/app/commit/diff.txt")

    commit_message = ""

    for i, section in enumerate(result, start=1):
        section_path = f"/app/commit/diff_{i}.txt"
        FileUtils.write_to_file(section_path, section)
        args.type = "txt"
        args.path = section_path
        args.system_prompt_template = f"You are AI model for 'git commit' message generation from content of '{section_path}'."
        args.collection_name = f"git_diff_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        chatbot = PipelineUtils.create_chatbot(args)
        generated_message = create_commit_message(chatbot)
        if generated_message:
            commit_message += "\n\n" + generated_message
        else:
            logger.error("Failed to generate commit message for section %d.", i)
            # Optionally, handle this scenario as needed
        chatbot.delete_collection()
        chatbot.clear_chat_history()
        FileUtils.delete_file(section_path)

    # Step 3: Write the commit message to a file
    create_commit_message_file(commit_message)

    logger.info("Commit message generated successfully.")


if __name__ == "__main__":
    main()
