import subprocess
import sys
import os
from datetime import datetime
from pipeline import PipelineUtils, ChatbotUtils, logger, FileUtils

def run_command(command):
    """Run a shell command and return the output."""
    try:
        result = subprocess.run(command, text=True, capture_output=True, check=True)
        return result.stdout.strip(), result.returncode
    except subprocess.CalledProcessError as e:
        logger.exception("Error running command '%s': %s", " ".join(command), e)
        sys.exit(e.returncode)

def split_diff_by_file(diff_path:str) -> list:
    """
    Splits the diff content into sections, one for each file.
    param: diff_content: The diff content to split.
    return: A list of sections, each containing the diff content for a single file.
    """

    diff_content = FileUtils.read_file(diff_path)

    sections = []
    current_section = []

    for line in diff_content.splitlines():
        if line.startswith('diff --git'):
            if current_section:
                sections.append('\n'.join(current_section))
                current_section = []
        current_section.append(line)

    if current_section:
        sections.append('\n'.join(current_section))

    return sections


def run_checks(chatbot):
    """
    Run checks before creating the commit message.
    params: chatbot: The chatbot object to interact with the AI model.
    return: True if all checks pass, False otherwise.
    """
    security_check = chatbot.invoke("Confirm that the changes do not contain any sensitive information.")
    vulnerability_check = chatbot.invoke("Confirm that the changes do not introduce any security vulnerabilities.")
    code_quality_check = chatbot.invoke("Confirm that the changes meet the code quality standards.")
    pylint_check = chatbot.invoke("Confirm that the changes pass the pylint check.")

    # Simplified validation flow
    for check, message in zip(
        [security_check, vulnerability_check, code_quality_check, pylint_check],
        ["Security", "Vulnerability", "Code Quality", "Pylint"]
    ):
        logger.info(f"{message} check: {check}")
        response = input(f"Is the {message} check okay? (y/n): ").strip().lower()
        if response == "n":
            return False

    return True

def create_commit_message(chatbot) -> str:
    """
    Create a commit message using the chatbot.
    params: chatbot: The chatbot object to interact with the AI model.
    return: The generated commit message or False if the process is aborted.
    """
    logger.info("Running chatbot to generate commit message...")
    try:
        commit_message = chatbot.invoke(
            """
            Write a detailed commit message based on the provided content.
            Format the commit message as JSON with the keys:
            'title', 'description' (list of sentences), and 'type' (e.g., feature, bugfix).
            """
        )

        logger.info("Commit message generated by chatbot: %s", commit_message)

        if commit_message:
            commit_message_json = ChatbotUtils.parse_json(commit_message)
            if commit_message_json is None:
                logger.warning("Invalid JSON format. Trying again... Press CTRL+C to abort.")
                return None
            commit_message = commit_message_json.get('title', 'No Title!')
            commit_message += "\n\nDescription:\n"
            description = commit_message_json.get('description', ['No Description!'])
            for i, sentence in enumerate(description, start=1):
                commit_message += f"{i}. {sentence.strip()}.\n"
            commit_message += f"\nType: {commit_message_json.get('type', 'No Type!')}"

            logger.info("Generated commit message: %s", commit_message)

        return commit_message
    except KeyboardInterrupt:
        logger.error("Aborting commit.")
    except ValueError as e:
        logger.error("Error generating commit message: %s", e)

    return False

def main():
    """Main function to generate commit message."""

    # Step 2: Create chatbot to run checks and generate commit message
    args = PipelineUtils.get_args()
    args.type = "txt"

    result = split_diff_by_file(args.path)

    commit_message = ""

    for i, section in enumerate(result, start=1):
        section_path = f"/app/commit/diff_{i}.txt"
        FileUtils.write_file(section_path, section)
        args.path = section_path
        args.system_prompt_template = "You are AI model for 'git commit' message generation from content of 'diff.txt'."
        args.collection_name = f"git_diff_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        chatbot = PipelineUtils.create_chatbot(args)
        commit_message =+ create_commit_message(chatbot)
        chatbot.delete_collection()
        chatbot.clear_chat_history()
        FileUtils.delete_file(section_path)

    FileUtils.write_file("/app/commit/commit_message.txt", commit_message)

    logger.info("Commit message generated successfully.")

if __name__ == "__main__":
    main()
